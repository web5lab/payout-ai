# User-Centric Schema for Complete Offering Ecosystem

# ============================================
# USER ENTITIES (Main Focus)
# ============================================

type User @entity {
  id: Bytes! # user address
  address: Bytes!
  
  # Investment Activity
  totalInvestments: BigInt!
  totalInvestmentVolume: BigInt! # USD value
  totalTokensReceived: BigInt!
  totalTokensClaimed: BigInt!
  
  # Payout Activity
  totalPayoutsReceived: BigInt!
  totalPayoutsClaimed: BigInt!
  activeWrappedTokens: BigInt!
  
  # Emergency Activity
  totalEmergencyUnlocks: BigInt!
  totalPenaltiesPaid: BigInt!
  
  # Offering Creation (if user is a creator)
  totalOfferingsCreated: BigInt!
  totalFundsRaised: BigInt! # As offering creator
  
  # Timestamps
  firstActivityAt: BigInt!
  lastActivityAt: BigInt!
  
  # Derived relationships
  investments: [UserInvestment!]! @derivedFrom(field: "user")
  claims: [UserClaim!]! @derivedFrom(field: "user")
  payouts: [UserPayout!]! @derivedFrom(field: "user")
  wrappedTokenHoldings: [UserWrappedTokenHolding!]! @derivedFrom(field: "user")
  createdOfferings: [Offering!]! @derivedFrom(field: "creator")
  emergencyUnlocks: [UserEmergencyUnlock!]! @derivedFrom(field: "user")
  refunds: [UserRefund!]! @derivedFrom(field: "user")
  kybValidations: [UserKYBValidation!]! @derivedFrom(field: "user")
  notifications: [UserNotification!]! @derivedFrom(field: "user")
  activityHistory: [UserActivityHistory!]! @derivedFrom(field: "user")
}

# ============================================
# USER ACTIVITY ENTITIES
# ============================================

type UserInvestment @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  offering: Offering!
  offeringAddress: Bytes!
  paymentToken: Bytes!
  paymentTokenSymbol: String!
  paidAmount: BigInt!
  usdValue: BigInt!
  tokensReceived: BigInt!
  isKYBValidated: Boolean!
  isNativeETH: Boolean!
  hasWrappedTokens: Boolean!
  wrappedTokenAddress: Bytes
  wrappedTokensReceived: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  gasUsed: BigInt!
  gasPrice: BigInt!
}

type UserClaim @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  offering: Offering
  offeringAddress: Bytes
  claimType: String! # "investment_tokens", "final_tokens", "refund", "emergency_unlock"
  amount: BigInt!
  tokenAddress: Bytes!
  tokenSymbol: String!
  isEmergencyUnlock: Boolean!
  penaltyAmount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserPayout @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  amount: BigInt!
  payoutToken: Bytes!
  payoutTokenSymbol: String!
  payoutPeriod: BigInt!
  userWrappedBalance: BigInt!
  totalWrappedSupply: BigInt!
  sharePercentage: BigInt! # basis points (10000 = 100%)
  isPartialClaim: Boolean!
  remainingClaimable: BigInt!
  payoutDistribution: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserWrappedTokenHolding @entity {
  id: Bytes! # user address + wrapped token address
  user: User!
  userAddress: Bytes!
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  currentBalance: BigInt!
  originalInvestment: BigInt!
  usdValueInvested: BigInt!
  totalPayoutsReceived: BigInt!
  totalPayoutsClaimed: BigInt!
  currentClaimablePayouts: BigInt!
  lastClaimedPeriod: BigInt!
  isActive: Boolean!
  hasClaimedFinal: Boolean!
  hasEmergencyUnlocked: Boolean!
  firstInvestmentAt: BigInt!
  lastActivityAt: BigInt!
}

type UserEmergencyUnlock @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  originalAmount: BigInt!
  penaltyAmount: BigInt!
  receivedAmount: BigInt!
  penaltyPercentage: BigInt! # basis points
  totalPayoutsClaimedBefore: BigInt!
  unlockedAt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserRefund @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  offering: Offering!
  offeringAddress: Bytes!
  token: Bytes!
  tokenSymbol: String!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserKYBValidation @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  validator: Bytes!
  signatureHash: Bytes!
  validatedAt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ============================================
# OFFERING ENTITIES
# ============================================

type Offering @entity {
  id: Bytes! # offering contract address
  creator: User!
  creatorAddress: Bytes!
  tokenOwner: Bytes!
  saleToken: Bytes!
  saleTokenSymbol: String!
  minInvestment: BigInt!
  maxInvestment: BigInt!
  startDate: BigInt!
  endDate: BigInt!
  maturityDate: BigInt!
  fundraisingCap: BigInt!
  softCap: BigInt!
  tokenPrice: BigInt!
  autoTransfer: Boolean!
  apyEnabled: Boolean!
  wrappedTokenAddress: Bytes
  payoutTokenAddress: Bytes
  payoutRate: BigInt!
  
  # Status
  isActive: Boolean!
  isFinalized: Boolean!
  isCancelled: Boolean!
  softCapReached: Boolean!
  
  # Statistics
  totalRaised: BigInt!
  totalInvestors: BigInt!
  totalTokensDistributed: BigInt!
  totalRefunded: BigInt!
  
  # Timestamps
  createdAt: BigInt!
  createdBlock: BigInt!
  finalizedAt: BigInt
  cancelledAt: BigInt
  
  # Derived relationships
  investments: [UserInvestment!]! @derivedFrom(field: "offering")
  claims: [UserClaim!]! @derivedFrom(field: "offering")
  refunds: [UserRefund!]! @derivedFrom(field: "offering")
}

type OfferingPerformance @entity {
  id: Bytes! # offering address
  offering: Offering!
  offeringAddress: Bytes!
  totalInvestors: BigInt!
  averageInvestmentSize: BigInt!
  largestInvestment: BigInt!
  smallestInvestment: BigInt!
  raisedInFirst24Hours: BigInt!
  raisedInFirstWeek: BigInt!
  timeToSoftCap: BigInt!
  timeToHardCap: BigInt!
  tokensClaimedPercentage: BigInt! # basis points
  refundedPercentage: BigInt! # basis points
  totalPayoutsDistributed: BigInt!
  averagePayoutPerUser: BigInt!
  emergencyUnlockRate: BigInt! # basis points
  lastUpdated: BigInt!
}

type OfferingDeployment @entity {
  id: Bytes! # transaction hash + log index
  offeringId: BigInt!
  creator: User!
  creatorAddress: Bytes!
  offeringAddress: Bytes!
  tokenOwner: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ============================================
# WRAPPED TOKEN ENTITIES
# ============================================

type WrappedToken @entity {
  id: Bytes! # wrapped token contract address
  name: String!
  symbol: String!
  offering: Offering
  offeringAddress: Bytes!
  peggedToken: Bytes!
  payoutToken: Bytes!
  payoutTokenSymbol: String!
  maturityDate: BigInt!
  payoutAPR: BigInt!
  payoutPeriodDuration: BigInt!
  firstPayoutDate: BigInt!
  currentPayoutPeriod: BigInt!
  lastPayoutDistributionTime: BigInt!
  totalSupply: BigInt!
  totalEscrowed: BigInt!
  totalUSDTInvested: BigInt!
  totalPayoutFundsDistributed: BigInt!
  totalPayoutsClaimed: BigInt!
  currentPayoutFunds: BigInt!
  emergencyUnlockEnabled: Boolean!
  emergencyUnlockPenalty: BigInt!
  totalEmergencyUnlocks: BigInt!
  totalHolders: BigInt!
  activeHolders: BigInt!
  createdAt: BigInt!
  createdBlock: BigInt!
  
  # Derived relationships
  holders: [UserWrappedTokenHolding!]! @derivedFrom(field: "wrappedToken")
  payouts: [UserPayout!]! @derivedFrom(field: "wrappedToken")
  emergencyUnlocks: [UserEmergencyUnlock!]! @derivedFrom(field: "wrappedToken")
  payoutDistributions: [PayoutDistribution!]! @derivedFrom(field: "wrappedToken")
}

type WrappedTokenDeployment @entity {
  id: Bytes! # transaction hash + log index
  tokenId: BigInt!
  creator: User!
  creatorAddress: Bytes!
  wrappedTokenAddress: Bytes!
  offeringContract: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PayoutDistribution @entity {
  id: Bytes! # wrapped token address + period + "distribution"
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  period: BigInt!
  amount: BigInt!
  totalUSDTAtDistribution: BigInt!
  distributedBy: Bytes!
  distributedAt: BigInt!
  eligibleHolders: BigInt!
  totalEligibleBalance: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PayoutPeriod @entity {
  id: Bytes! # wrapped token address + period number
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  periodNumber: BigInt!
  distributedAmount: BigInt!
  totalUSDTAtDistribution: BigInt!
  distributedAt: BigInt!
  distributedBy: Bytes!
  totalClaims: BigInt!
  totalClaimedAmount: BigInt!
  unclaimedAmount: BigInt!
  claimRate: BigInt! # basis points
  eligibleUsers: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# ============================================
# ANALYTICS ENTITIES
# ============================================

type GlobalStats @entity {
  id: Bytes! # "global"
  totalUsers: BigInt!
  activeInvestors: BigInt!
  totalCreators: BigInt!
  totalOfferings: BigInt!
  activeOfferings: BigInt!
  totalOfferingVolume: BigInt!
  totalInvestments: BigInt!
  totalInvestmentVolume: BigInt!
  totalWrappedTokens: BigInt!
  activeWrappedTokens: BigInt!
  totalWrappedTokenHolders: BigInt!
  totalPayoutDistributions: BigInt!
  totalPayoutVolume: BigInt!
  totalPayoutsClaimed: BigInt!
  totalEmergencyUnlocks: BigInt!
  totalPenaltiesPaid: BigInt!
  totalRefunds: BigInt!
  totalRefundVolume: BigInt!
  totalKYBValidations: BigInt!
  kybValidatedInvestments: BigInt!
  lastUpdated: BigInt!
}

type UserDailyStats @entity {
  id: Bytes! # user address + date
  user: User!
  userAddress: Bytes!
  date: String! # YYYY-MM-DD
  investmentsCount: BigInt!
  investmentVolume: BigInt!
  claimsCount: BigInt!
  claimedAmount: BigInt!
  payoutsCount: BigInt!
  payoutAmount: BigInt!
  totalInvestmentVolume: BigInt!
  totalTokensHeld: BigInt!
  totalPayoutsReceived: BigInt!
}

type UserMonthlyStats @entity {
  id: Bytes! # user address + year-month
  user: User!
  userAddress: Bytes!
  yearMonth: String! # YYYY-MM
  investmentsCount: BigInt!
  investmentVolume: BigInt!
  claimsCount: BigInt!
  claimedAmount: BigInt!
  payoutsCount: BigInt!
  payoutAmount: BigInt!
  avgInvestmentSize: BigInt!
  avgPayoutSize: BigInt!
}

type DailySystemStats @entity {
  id: Bytes! # date
  date: String! # YYYY-MM-DD
  newUsers: BigInt!
  newOfferings: BigInt!
  newInvestments: BigInt!
  investmentVolume: BigInt!
  payoutDistributions: BigInt!
  payoutVolume: BigInt!
  payoutClaims: BigInt!
  emergencyUnlocks: BigInt!
  emergencyVolume: BigInt!
  totalUsers: BigInt!
  totalOfferings: BigInt!
  totalInvestmentVolume: BigInt!
}

# ============================================
# NOTIFICATION ENTITIES
# ============================================

type UserNotification @entity {
  id: Bytes! # user address + timestamp + type
  user: User!
  userAddress: Bytes!
  notificationType: String!
  title: String!
  message: String!
  priority: String! # "low", "medium", "high", "urgent"
  isRead: Boolean!
  isActionable: Boolean!
  createdAt: BigInt!
  readAt: BigInt
  expiresAt: BigInt
  relatedOffering: Bytes
  relatedWrappedToken: Bytes
  relatedAmount: BigInt!
}

type UserActivityHistory @entity {
  id: Bytes! # user address + timestamp + activity type
  user: User!
  userAddress: Bytes!
  activityType: String!
  description: String!
  amount: BigInt!
  tokenAddress: Bytes!
  offeringAddress: Bytes
  wrappedTokenAddress: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!