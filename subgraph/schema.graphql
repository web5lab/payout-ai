# User-Centric Schema for Complete Offering Ecosystem

# ============================================
# USER ENTITIES (Main Focus)
# ============================================

type User @entity {
  id: Bytes! # user address
  address: Bytes!
  
  # Investment Activity
  totalInvestments: BigInt!
  totalInvestmentVolume: BigInt! # USD value
  totalTokensReceived: BigInt!
  totalTokensClaimed: BigInt!
  
  # Payout Activity
  totalPayoutsReceived: BigInt!
  totalPayoutsClaimed: BigInt!
  activeWrappedTokens: BigInt!
  
  # Emergency Activity
  totalEmergencyUnlocks: BigInt!
  totalPenaltiesPaid: BigInt!
  
  # Offering Creation (if user is a creator)
  totalOfferingsCreated: BigInt!
  totalFundsRaised: BigInt! # As offering creator
  
  # Timestamps
  firstActivityAt: BigInt!
  lastActivityAt: BigInt!
  
  # Derived relationships
  investments: [UserInvestment!]! @derivedFrom(field: "user")
  aggregatedInvestments: [UserOfferingInvestment!]! @derivedFrom(field: "user")
  claims: [UserClaim!]! @derivedFrom(field: "user")
  payouts: [UserPayout!]! @derivedFrom(field: "user")
  wrappedTokenHoldings: [UserWrappedTokenHolding!]! @derivedFrom(field: "user")
  createdOfferings: [Offering!]! @derivedFrom(field: "creator")
  emergencyUnlocks: [UserEmergencyUnlock!]! @derivedFrom(field: "user")
  refunds: [UserRefund!]! @derivedFrom(field: "user")
  kybValidations: [UserKYBValidation!]! @derivedFrom(field: "user")
  notifications: [UserNotification!]! @derivedFrom(field: "user")
  activityHistory: [UserActivityHistory!]! @derivedFrom(field: "user")
}

type UserOfferingInvestment @entity {
  id: Bytes! # user address + offering address
  user: User!
  userAddress: Bytes!
  offering: Offering!
  offeringAddress: Bytes!
  
  # Aggregated investment data
  totalInvestments: BigInt!
  totalPaidAmount: BigInt!
  totalUSDValue: BigInt!
  totalTokensReceived: BigInt!
  totalWrappedTokensReceived: BigInt!
  
  # Payment method breakdown
  totalETHInvested: BigInt!
  totalERC20Invested: BigInt!
  
  # KYB tracking
  totalKYBValidatedInvestments: BigInt!
  
  # Status tracking
  hasClaimedTokens: Boolean!
  totalTokensClaimed: BigInt!
  hasReceivedRefund: Boolean!
  totalRefundReceived: BigInt!
  
  # Timestamps
  firstInvestmentAt: BigInt!
  lastInvestmentAt: BigInt!
  
  # Link to individual investments
  individualInvestments: [UserInvestment!]! @derivedFrom(field: "aggregatedInvestment")
}

# ============================================
# USER ACTIVITY ENTITIES
# ============================================

type UserInvestment @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  offering: Offering!
  offeringAddress: Bytes!
  paymentToken: Bytes!
  paymentTokenSymbol: String!
  paidAmount: BigInt!
  usdValue: BigInt!
  tokensReceived: BigInt!
  isKYBValidated: Boolean!
  isNativeETH: Boolean!
  hasWrappedTokens: Boolean!
  wrappedTokenAddress: Bytes
  wrappedTokensReceived: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  gasUsed: BigInt!
  gasPrice: BigInt!
  
  # Link to aggregated investment
  aggregatedInvestment: UserOfferingInvestment!
}

type UserClaim @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  offering: Offering
  offeringAddress: Bytes
  claimType: String! # "investment_tokens", "final_tokens", "refund", "emergency_unlock"
  amount: BigInt!
  tokenAddress: Bytes!
  tokenSymbol: String!
  isEmergencyUnlock: Boolean!
  penaltyAmount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserPayout @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  offering: Offering # Link to offering (null if not APY-enabled)
  offeringAddress: Bytes!
  amount: BigInt!
  payoutToken: Bytes!
  payoutTokenSymbol: String!
  payoutPeriodNumber: BigInt!
  userWrappedBalance: BigInt!
  totalWrappedSupply: BigInt!
  sharePercentage: BigInt! # basis points (10000 = 100%)
  isPartialClaim: Boolean!
  remainingClaimable: BigInt!
  payoutDistribution: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserWrappedTokenHolding @entity {
  id: Bytes! # user address + wrapped token address
  user: User!
  userAddress: Bytes!
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  currentBalance: BigInt!
  originalInvestment: BigInt!
  usdValueInvested: BigInt!
  totalPayoutsReceived: BigInt!
  totalPayoutsClaimed: BigInt!
  currentClaimablePayouts: BigInt!
  lastClaimedPeriod: BigInt!
  isActive: Boolean!
  hasClaimedFinal: Boolean!
  hasEmergencyUnlocked: Boolean!
  firstInvestmentAt: BigInt!
  lastActivityAt: BigInt!
}

type UserEmergencyUnlock @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  originalAmount: BigInt!
  penaltyAmount: BigInt!
  receivedAmount: BigInt!
  penaltyPercentage: BigInt! # basis points
  totalPayoutsClaimedBefore: BigInt!
  unlockedAt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserRefund @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  offering: Offering!
  offeringAddress: Bytes!
  token: Bytes!
  tokenSymbol: String!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UserKYBValidation @entity {
  id: Bytes! # transaction hash + log index
  user: User!
  userAddress: Bytes!
  validator: Bytes!
  signatureHash: Bytes!
  validatedAt: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ============================================
# OFFERING ENTITIES
# ============================================

type Offering @entity {
  id: Bytes! # offering contract address
  creator: User!
  creatorAddress: Bytes!
  tokenOwner: Bytes!
  saleToken: Bytes!
  saleTokenSymbol: String!
  saleTokenName: String!
  saleTokenDecimals: BigInt!
  minInvestment: BigInt!
  maxInvestment: BigInt!
  startDate: BigInt!
  endDate: BigInt!
  maturityDate: BigInt!
  fundraisingCap: BigInt!
  softCap: BigInt!
  tokenPrice: BigInt!
  autoTransfer: Boolean!
  apyEnabled: Boolean!
  wrappedTokenAddress: Bytes
  payoutTokenAddress: Bytes
  payoutRate: BigInt!
  
  # Status
  isActive: Boolean!
  isFinalized: Boolean!
  isCancelled: Boolean!
  softCapReached: Boolean!
  
  # Statistics
  totalRaised: BigInt!
  totalInvestors: BigInt!
  totalTokensDistributed: BigInt!
  totalRefunded: BigInt!
  
  # Payout Statistics (for APY-enabled offerings)
  totalPayoutDistributions: BigInt!
  totalPayoutVolume: BigInt!
  totalPayoutsClaimed: BigInt!
  currentPayoutPeriod: BigInt!
  nextPayoutTime: BigInt!
  payoutStatus: String! # "not_applicable", "waiting", "ready", "active", "completed"
  
  # Predictable Payout Schedule (for APY-enabled offerings)
  totalPayoutRounds: BigInt!
  payoutPeriodDuration: BigInt!
  firstPayoutDate: BigInt!
  payoutScheduleCreated: Boolean!
  expectedPayoutPerRound: BigInt!
  totalExpectedPayouts: BigInt!
  payoutScheduleAccuracy: BigInt! # basis points (10000 = 100%)
  payoutTimingAccuracy: BigInt! # basis points for on-time delivery
  completedPayoutRounds: BigInt!
  
  # Timestamps
  createdAt: BigInt!
  createdBlock: BigInt!
  finalizedAt: BigInt
  cancelledAt: BigInt
  
  # Investment transactions for this offering
  investmentTransactions: [OfferingInvestmentTransaction!]! @derivedFrom(field: "offering")
  
  # Direct relationship to all investment transactions
  transactions: [OfferingInvestmentTransaction!]! @derivedFrom(field: "offering")
  
  # Payout relationships (only for APY-enabled offerings)
  payoutDistributions: [PayoutDistribution!]! @derivedFrom(field: "offering")
  payoutPeriods: [PayoutPeriod!]! @derivedFrom(field: "offering")
  userPayouts: [UserPayout!]! @derivedFrom(field: "offering")
  upcomingPayouts: [UserUpcomingPayout!]! @derivedFrom(field: "offering")
  
  # Predictable payout schedule
  payoutRounds: [OfferingPayoutRound!]! @derivedFrom(field: "offering")
}
}

type OfferingInvestmentTransaction @entity {
  id: Bytes! # transaction hash + log index
  offering: Offering!
  offeringAddress: Bytes!
  investor: User!
  investorAddress: Bytes!
  paymentToken: Bytes!
  paymentTokenSymbol: String!
  investmentAmount: BigInt! # Amount paid by investor
  tokensReceived: BigInt! # Tokens received by investor
  usdValue: BigInt! # USD value of investment
  isKYBValidated: Boolean!
  isNativeETH: Boolean!
  hasWrappedTokens: Boolean!
  wrappedTokenAddress: Bytes
  wrappedTokensReceived: BigInt!
  
  # Transaction details
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  gasUsed: BigInt!
  gasPrice: BigInt!
}

type OfferingPerformance @entity {
  id: Bytes! # offering address
  offering: Offering!
  offeringAddress: Bytes!
  totalInvestors: BigInt!
  averageInvestmentSize: BigInt!
  largestInvestment: BigInt!
  smallestInvestment: BigInt!
  raisedInFirst24Hours: BigInt!
  raisedInFirstWeek: BigInt!
  timeToSoftCap: BigInt!
  timeToHardCap: BigInt!
  tokensClaimedPercentage: BigInt! # basis points
  refundedPercentage: BigInt! # basis points
  totalPayoutsDistributed: BigInt!
  averagePayoutPerUser: BigInt!
  emergencyUnlockRate: BigInt! # basis points
  lastUpdated: BigInt!
}

type OfferingDeployment @entity {
  id: Bytes! # transaction hash + log index
  offeringId: BigInt!
  creator: User!
  creatorAddress: Bytes!
  offeringAddress: Bytes!
  tokenOwner: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ============================================
# WRAPPED TOKEN ENTITIES
# ============================================

type WrappedToken @entity {
  id: Bytes! # wrapped token contract address
  name: String!
  symbol: String!
  offering: Offering
  offeringAddress: Bytes!
  peggedToken: Bytes!
  payoutToken: Bytes!
  payoutTokenSymbol: String!
  maturityDate: BigInt!
  payoutAPR: BigInt!
  payoutPeriodDuration: BigInt!
  totalPayoutRounds: BigInt!
  firstPayoutDate: BigInt!
  currentPayoutPeriod: BigInt!
  lastPayoutDistributionTime: BigInt!
  nextPayoutTime: BigInt!
  isPayoutPeriodAvailable: Boolean!
  expectedPayoutPerPeriod: BigInt!
  totalExpectedPayouts: BigInt!
  payoutVariance: BigInt! # Difference between expected and actual
  payoutAccuracy: BigInt! # Percentage accuracy in basis points
  totalSupply: BigInt!
  totalEscrowed: BigInt!
  totalUSDTInvested: BigInt!
  totalPayoutFundsDistributed: BigInt!
  totalPayoutsClaimed: BigInt!
  currentPayoutFunds: BigInt!
  requiredPayoutTokens: BigInt!
  payoutStatus: String! # "waiting", "ready", "distributed", "completed"
  payoutScheduleStatus: String! # "not_set", "scheduled", "active", "completed"
  emergencyUnlockEnabled: Boolean!
  emergencyUnlockPenalty: BigInt!
  totalEmergencyUnlocks: BigInt!
  totalHolders: BigInt!
  activeHolders: BigInt!
  createdAt: BigInt!
  createdBlock: BigInt!
  
  # Derived relationships
  payoutPeriods: [PayoutPeriod!]! @derivedFrom(field: "wrappedToken")
  upcomingPayouts: [UserUpcomingPayout!]! @derivedFrom(field: "wrappedToken")
  payoutSchedule: [PayoutSchedule!]! @derivedFrom(field: "wrappedToken")
}

type WrappedTokenDeployment @entity {
  id: Bytes! # transaction hash + log index
  tokenId: BigInt!
  creator: User!
  creatorAddress: Bytes!
  wrappedTokenAddress: Bytes!
  offeringContract: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PayoutDistribution @entity {
  id: Bytes! # wrapped token address + period + "distribution"
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  offering: Offering # Link to offering (null if not APY-enabled)
  offeringAddress: Bytes!
  period: BigInt!
  amount: BigInt!
  totalUSDTAtDistribution: BigInt!
  distributedBy: Bytes!
  distributedAt: BigInt!
  eligibleHolders: BigInt!
  totalEligibleBalance: BigInt!
  averagePayoutPerUser: BigInt!
  claimRate: BigInt! # basis points (claimed/distributed * 10000)
  status: String! # "distributed", "partially_claimed", "fully_claimed"
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PayoutPeriod @entity {
  id: Bytes! # wrapped token address + period number
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  offering: Offering # Link to offering (null if not APY-enabled)
  offeringAddress: Bytes!
  periodNumber: BigInt!
  expectedStartTime: BigInt!
  expectedEndTime: BigInt!
  expectedAmount: BigInt!
  actualAmount: BigInt!
  amountVariance: BigInt!
  accuracyPercentage: BigInt! # basis points
  startTime: BigInt!
  endTime: BigInt!
  distributedAmount: BigInt!
  totalUSDTAtDistribution: BigInt!
  distributedAt: BigInt!
  distributedBy: Bytes!
  totalClaims: BigInt!
  totalClaimedAmount: BigInt!
  unclaimedAmount: BigInt!
  claimRate: BigInt! # basis points
  eligibleUsers: BigInt!
  status: String! # "upcoming", "active", "distributed", "completed"
  isOnSchedule: Boolean!
  delayFromSchedule: BigInt! # seconds delayed from expected time
  blockNumber: BigInt!
  transactionHash: Bytes!
}

# New entity to track the complete payout schedule
type PayoutSchedule @entity {
  id: Bytes! # wrapped token address + period number + "schedule"
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  offering: Offering!
  offeringAddress: Bytes!
  periodNumber: BigInt!
  expectedPayoutTime: BigInt!
  expectedAmount: BigInt!
  actualPayoutTime: BigInt!
  actualAmount: BigInt!
  isDistributed: Boolean!
  isOnTime: Boolean!
  delayInSeconds: BigInt!
  amountVariance: BigInt!
  accuracyPercentage: BigInt! # basis points
  status: String! # "scheduled", "due", "distributed", "overdue"
  createdAt: BigInt!
  updatedAt: BigInt!
}

# New entity to track offering-level payout rounds (predictable schedule)
type OfferingPayoutRound @entity {
  id: Bytes! # offering address + round number
  offering: Offering!
  offeringAddress: Bytes!
  wrappedToken: WrappedToken
  wrappedTokenAddress: Bytes
  roundNumber: BigInt!
  expectedPayoutTime: BigInt!
  expectedAmount: BigInt!
  actualPayoutTime: BigInt!
  actualAmount: BigInt!
  isDistributed: Boolean!
  isOnTime: Boolean!
  delayInSeconds: BigInt!
  amountVariance: BigInt! # actual - expected
  timingAccuracy: BigInt! # basis points (10000 = perfect timing)
  amountAccuracy: BigInt! # basis points (10000 = perfect amount)
  status: String! # "scheduled", "due", "distributed", "completed", "overdue"
  eligibleInvestors: BigInt!
  totalClaimsForRound: BigInt!
  totalClaimedAmount: BigInt!
  claimRate: BigInt! # basis points (claimed/distributed * 10000)
  createdAt: BigInt!
  updatedAt: BigInt!
  
  # Link to the actual payout distribution when it happens
  payoutDistribution: PayoutDistribution
  payoutPeriod: PayoutPeriod
}

type UserUpcomingPayout @entity {
  id: Bytes! # user address + wrapped token address + period
  user: User!
  userAddress: Bytes!
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  offering: Offering # Link to offering (null if not APY-enabled)
  offeringAddress: Bytes!
  periodNumber: BigInt!
  expectedPayoutTime: BigInt!
  estimatedAmount: BigInt!
  userUSDTValue: BigInt!
  totalUSDTAtPeriod: BigInt!
  sharePercentage: BigInt! # basis points
  isClaimable: Boolean!
  isDistributed: Boolean!
  isClaimed: Boolean!
  actualPayoutTime: BigInt!
  claimedAt: BigInt!
  createdAt: BigInt!
  updatedAt: BigInt!
}

type PayoutCalculation @entity {
  id: Bytes! # wrapped token address + period + "calculation"
  wrappedToken: WrappedToken!
  wrappedTokenAddress: Bytes!
  periodNumber: BigInt!
  totalUSDTInvested: BigInt!
  periodAPR: BigInt!
  requiredPayoutTokens: BigInt!
  actualDistributedTokens: BigInt!
  calculatedAt: BigInt!
  distributedAt: BigInt!
  variance: BigInt! # difference between required and actual
  variancePercentage: BigInt! # basis points
}
# ============================================
# ANALYTICS ENTITIES
# ============================================

type GlobalStats @entity {
  id: Bytes! # "global"
  totalUsers: BigInt!
  activeInvestors: BigInt!
  totalCreators: BigInt!
  totalOfferings: BigInt!
  activeOfferings: BigInt!
  totalOfferingVolume: BigInt!
  totalInvestments: BigInt!
  totalInvestmentVolume: BigInt!
  totalWrappedTokens: BigInt!
  activeWrappedTokens: BigInt!
  totalWrappedTokenHolders: BigInt!
  totalPayoutDistributions: BigInt!
  totalPayoutVolume: BigInt!
  totalPayoutsClaimed: BigInt!
  totalEmergencyUnlocks: BigInt!
  totalPenaltiesPaid: BigInt!
  totalRefunds: BigInt!
  totalRefundVolume: BigInt!
  totalKYBValidations: BigInt!
  kybValidatedInvestments: BigInt!
  lastUpdated: BigInt!
}

type UserDailyStats @entity {
  id: Bytes! # user address + date
  user: User!
  userAddress: Bytes!
  date: String! # YYYY-MM-DD
  investmentsCount: BigInt!
  investmentVolume: BigInt!
  claimsCount: BigInt!
  claimedAmount: BigInt!
  payoutsCount: BigInt!
  payoutAmount: BigInt!
  totalInvestmentVolume: BigInt!
  totalTokensHeld: BigInt!
  totalPayoutsReceived: BigInt!
}

type UserMonthlyStats @entity {
  id: Bytes! # user address + year-month
  user: User!
  userAddress: Bytes!
  yearMonth: String! # YYYY-MM
  investmentsCount: BigInt!
  investmentVolume: BigInt!
  claimsCount: BigInt!
  claimedAmount: BigInt!
  payoutsCount: BigInt!
  payoutAmount: BigInt!
  avgInvestmentSize: BigInt!
  avgPayoutSize: BigInt!
}

type DailySystemStats @entity {
  id: Bytes! # date
  date: String! # YYYY-MM-DD
  newUsers: BigInt!
  newOfferings: BigInt!
  newInvestments: BigInt!
  investmentVolume: BigInt!
  payoutDistributions: BigInt!
  payoutVolume: BigInt!
  payoutClaims: BigInt!
  emergencyUnlocks: BigInt!
  emergencyVolume: BigInt!
  totalUsers: BigInt!
  totalOfferings: BigInt!
  totalInvestmentVolume: BigInt!
}

# ============================================
# NOTIFICATION ENTITIES
# ============================================

type UserNotification @entity {
  id: Bytes! # user address + timestamp + type
  user: User!
  userAddress: Bytes!
  notificationType: String!
  title: String!
  message: String!
  priority: String! # "low", "medium", "high", "urgent"
  isRead: Boolean!
  isActionable: Boolean!
  createdAt: BigInt!
  readAt: BigInt
  expiresAt: BigInt
  relatedOffering: Bytes
  relatedWrappedToken: Bytes
  relatedAmount: BigInt!
}

type UserActivityHistory @entity {
  id: Bytes! # user address + timestamp + activity type
  user: User!
  userAddress: Bytes!
  activityType: String!
  description: String!
  amount: BigInt!
  tokenAddress: Bytes!
  offeringAddress: Bytes
  wrappedTokenAddress: Bytes
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}