# Investment and Offering Entities
type InvestmentRouted @entity(immutable: true) {
  id: Bytes!
  investor: Bytes! # address
  offering: Offering! # reference to offering entity
  offeringAddress: Bytes! # address for backwards compatibility
  paymentToken: Bytes! # address
  paidAmount: BigInt! # uint256
  tokensReceived: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type TotalInvestment @entity {
  id: Bytes! # offeringAddress-userAddress
  offeringAddress: Bytes!
  userAddress: Bytes!
  totalInvestment: BigInt!
  latestInvestmentTimestamp: BigInt!
  claimableTokens: BigInt!
  claimedTokens: BigInt!
  hasWrappedTokens: Boolean!
  wrappedTokenAddress: Bytes
  wrappedTokenBalance: BigInt!
}

type TokensClaimed @entity(immutable: true) {
  id: Bytes!
  investor: Bytes! # address
  offeringAddress: Bytes! # address
  amount: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# Offering Information
type Offering @entity {
  id: Bytes! # offering contract address
  saleToken: Bytes!
  tokenOwner: Bytes!
  minInvestment: BigInt!
  maxInvestment: BigInt!
  startDate: BigInt!
  endDate: BigInt!
  maturityDate: BigInt!
  fundraisingCap: BigInt!
  tokenPrice: BigInt!
  totalRaised: BigInt!
  autoTransfer: Boolean!
  apyEnabled: Boolean!
  wrappedTokenAddress: Bytes
  payoutTokenAddress: Bytes
  payoutRate: BigInt!
  isActive: Boolean!
  createdAt: BigInt!
  createdBlock: BigInt!
  investments: [InvestmentRouted!]! @derivedFrom(field: "offering")
  totalInvestors: BigInt!
}

# Wrapped Token and Payout Entities
type WrappedToken @entity {
  id: Bytes! # wrapped token contract address
  name: String!
  symbol: String!
  peggedToken: Bytes!
  payoutToken: Bytes!
  maturityDate: BigInt!
  payoutRate: BigInt!
  offeringContract: Bytes!
  totalSupply: BigInt!
  totalEscrowed: BigInt!
  totalPayoutFunds: BigInt!
  emergencyUnlockEnabled: Boolean!
  emergencyUnlockPenalty: BigInt!
  createdAt: BigInt!
  createdBlock: BigInt!
  # Derived relationships for ALL events
  investors: [WrappedTokenInvestor!]! @derivedFrom(field: "wrappedToken")
  payoutRounds: [PayoutRound!]! @derivedFrom(field: "wrappedToken")
  payoutClaims: [PayoutClaim!]! @derivedFrom(field: "wrappedToken")
  emergencyUnlocks: [EmergencyUnlock!]! @derivedFrom(field: "wrappedToken")
  finalTokenClaims: [FinalTokenClaim!]! @derivedFrom(field: "wrappedToken")
  transfers: [WrappedTokenTransfer!]! @derivedFrom(field: "wrappedToken")
  roleChanges: [RoleChange!]! @derivedFrom(field: "wrappedToken")
  pauseEvents: [PauseEvent!]! @derivedFrom(field: "wrappedToken")
}

type WrappedTokenInvestor @entity {
  id: Bytes! # wrappedTokenAddress-userAddress
  wrappedToken: WrappedToken!
  userAddress: Bytes!
  deposited: BigInt!
  wrappedBalance: BigInt!
  totalPayoutsClaimed: BigInt!
  totalPayoutBalance: BigInt!
  payoutFrequency: Int!
  lastPayoutTime: BigInt!
  hasClaimedTokens: Boolean!
  emergencyUnlocked: Boolean!
  registeredAt: BigInt!
  registeredBlock: BigInt!
}

# Payout System Entities
type PayoutRound @entity {
  id: Bytes! # wrappedTokenAddress-roundNumber
  wrappedToken: WrappedToken!
  roundNumber: BigInt!
  amount: BigInt!
  totalFundsAfterRound: BigInt!
  addedBy: Bytes! # payout admin address
  addedAt: BigInt!
  addedBlock: BigInt!
  transactionHash: Bytes!
  claims: [PayoutClaim!]! @derivedFrom(field: "payoutRound")
}

type PayoutClaim @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  payoutRound: PayoutRound
  wrappedToken: WrappedToken!
  user: Bytes! # address
  userSummary: UserPayoutSummary # reference to user summary
  amount: BigInt!
  remainingBalance: BigInt!
  claimedAt: BigInt!
  claimedBlock: BigInt!
  transactionHash: Bytes!
}

type UserPayoutSummary @entity {
  id: Bytes! # wrappedTokenAddress-userAddress
  wrappedToken: WrappedToken!
  userAddress: Bytes!
  totalClaimedAmount: BigInt!
  totalAvailableAmount: BigInt!
  currentClaimableAmount: BigInt!
  lastClaimTimestamp: BigInt!
  claimCount: BigInt!
  claims: [PayoutClaim!]! @derivedFrom(field: "userSummary")
}

# Emergency Unlock Entities
type EmergencyUnlock @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  wrappedToken: WrappedToken!
  user: Bytes!
  amount: BigInt! # amount returned to user
  penalty: BigInt! # penalty amount
  penaltyPercentage: BigInt!
  unlockedAt: BigInt!
  unlockedBlock: BigInt!
  transactionHash: Bytes!
}

# Final Token Claims
type FinalTokenClaim @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  wrappedToken: WrappedToken!
  user: Bytes!
  amount: BigInt!
  claimedAt: BigInt!
  claimedBlock: BigInt!
  transactionHash: Bytes!
}

# Global Statistics
type GlobalStats @entity {
  id: Bytes! # singleton entity with id "global"
  totalOfferings: BigInt!
  totalWrappedTokens: BigInt!
  totalInvestments: BigInt!
  totalInvestmentVolume: BigInt!
  totalPayoutFunds: BigInt!
  totalPayoutsClaimed: BigInt!
  totalEmergencyUnlocks: BigInt!
  totalFinalClaims: BigInt!
  lastUpdated: BigInt!
}

# Additional Wrapped Token Events
type WrappedTokenTransfer @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  wrappedToken: WrappedToken!
  from: Bytes!
  to: Bytes!
  value: BigInt!
  transferType: String! # "mint", "burn", "transfer"
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type RoleChange @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  wrappedToken: WrappedToken!
  role: Bytes!
  account: Bytes!
  sender: Bytes!
  action: String! # "granted" or "revoked"
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PauseEvent @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  wrappedToken: WrappedToken!
  action: String! # "paused" or "unpaused"
  account: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# Investment Registration Events (from wrapped token perspective)
type WrappedTokenInvestmentRegistration @entity(immutable: true) {
  id: Bytes! # transactionHash-logIndex
  wrappedToken: WrappedToken!
  user: Bytes!
  amount: BigInt!
  payoutFrequency: Int!
  registeredAt: BigInt!
  registeredBlock: BigInt!
  transactionHash: Bytes!
}

# Factory Events
type OfferingDeployed @entity(immutable: true) {
  id: Bytes!
  offeringId: BigInt!
  creator: Bytes!
  offeringAddress: Bytes!
  tokenOwner: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WrappedTokenDeployed @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt!
  creator: Bytes!
  wrappedTokenAddress: Bytes!
  offeringContract: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# Ownership and Admin Events
type OwnershipTransferred @entity(immutable: true) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}